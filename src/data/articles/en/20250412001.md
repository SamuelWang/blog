---
title: 'Accumulation Development in Frontend'
slug: 'accumulation-development-in-frontend'
author: 'Samuel Wang'
description: 'In software development, there are many chances to reuse development results, which can prevent us from reinventing the wheel and then accelerate development.'
tags: ['Frontend', 'Engineering']
releaseDate: '2025-04-12'
updateDate: '2025-04-12'
---

In software development, there are many chances to reuse development results, which can prevent us from reinventing the wheel and then accelerate development.

This article will describe which parts can be reused in Frontend development.

The development phases may be:

1. **Requirement definition phase:** PM defines requirements
2. **System analysis phase:** SA/Designer defines how to implement functionalities, and provides a wireframe or mockup
3. **Development phase:** FE developer develops the UI and functionalities
4. **Verification phase:** Stakeholder/QA tests functionalities
5. **Deployment phase:** Features are released

## UI Design System

A UI design system is a collection of reusable components, guidelines, and standards that help teams build consistent and cohesive user interfaces (UI) across digital products.

Key elements of a design system:

1. **Design tokens** — the smallest style values like color, typography, spacing, etc.
2. **Components** — reusable UI elements (buttons, cards, modals) built with consistent behavior and styling.
3. **Patterns** — common UX solutions to recurring problems (form layouts, error handling).
4. **Brand guidelines** — voice, tone, logos, imagery, and overall branding.
5. **Documentation** — detailed usage guidelines, dos and don’ts, and code snippets for devs.

Developing the design system can reuse elements to accelerate design and consistency. The design system can increase scalability. The new design can be based on the original design to increase functionalities and UX. It can also increase collaboration efficiency by using standards.

## Responsibilities for Frontend

The core responsibilities of Frontend may include:

- **UI Development**
- **State Management**
- **API Integration**
- Performance Optimization
- Cross-Browser compatibility
- Responsive Design
- Accessibility
- Tooling and Build Systems
- Testing
- The main daily development in Frontend usually includes UI development, state management, and API integration.

The main daily development in Frontend usually includes UI development, state management, and API integration.

## Mapping Responsibilities with FE Implementations

The **UI development** is mapped to components. In modern FE development, the UI is usually implemented as components, not pure HTML files.

The **API integration** is implemented by pure functions. The responsibilities of API functions are to receive parameters that APIs define and send requests to the server.

The **state management** includes encapsulation of business logic and UI behaviors. These implementations are placed in services, stores, and reactivities/signals.

## Drawbacks of All-in-one Component

Sometimes FE RDs may develop features by writing all implementations in one component. This way is actually no problem, features can be satisfied, and it works well. But this way violates the DRY principle, implementations can’t be reused in future development. For example, FE RDs have to implement the same UI again and again.

To prevent this situation and accelerate the speed of development, FE RDs should extract reusable parts from common materials as much as possible.

## Defining Categories in FE Development

The common FE development flow looks like:

1. Integrate APIs and get response data
2. Transform response data into view models and process business logic
3. Implement UIs
4. Manage states of views

In the above flows, the code of every stage can be categorized into different categories for maintenance and usability.

Categories:

- Data Access
- Service
- Component
- Hook/Reactivity/Signal
- Store

The following will describe every category.

## Data Access

Generally applications will send and retrieve data from the server or local storage. These access actions can be written as pure functions. Separating data access logic from the component can also decouple the logic from a component and reuse it in other places.

Using pure functions to write data access logic can be tested more easily. Giving specific parameters and mock data access requests, then verifying outputs.

The common pattern is to place functions of data access in the apis or data directories.

## Service

Models of views are usually different from models of raw data. After retrieving data, models of raw data should be transformed into view models. For example, the enum data may be numbers in the HTTP transmissions, the enum data should be transformed into the enum type of FE models.

Services don’t need to manage states, so services can be written as pure functions and placed in the `services` directory.

## Component

Years ago, people already knew that separating one component into components with a decoupled and well-defined interface can increase maintenance.

When all logic is in one component, it has to manage many flag states to control the display of different views. This makes the component become big and hard to modify.

There are two types of components, one is called pure UI component, and another is called smart component.

The UI component does not do any business logic, it is a pure UI component. It is used to display UI with specific behaviors. Besides displaying UI, the smart component also does business logic.

In order to make components reusable, the interface of components has to be decoupled and cohesive. Common components should not know the specific logic of any view, they receive props and do their responsibilities, not do anything only for a specific view.

## Hook/Reactivity/Signal

In the early FE development, developers used imperative programming. For instance, if we want to update the text of an element, we have to find that element and update its innerHTML value.

Nowadays, the modern FE frameworks use directive programming. For instance, the same example as the above, we just add a directive on that element and prepare reactive data, then bind them, the element’s text will be updated when the data is updated.

This pattern is also called data-driven. All things are reactive to data. And managing the data is also called state management.

In modern FE development, state management can be said to be the most important thing. As applications become more complex and big, their states will also be more complex.

In the state management of views, Vue introduces the reactivity system, Angular provides RxJS and signals, and React uses hooks to reuse states. The state management usually includes some rendering logic for views.

Before, the reactive data was usually placed in components, but now it can be extracted as individual functions, like hooks in React or composables in Vue. The states of views can also be reused now.

## Store

The states of reactivity are usually used in local components, and global states are usually placed in the global. There are many state management libraries, like Redux and Pinia. These libraries are called stores, they are usually used to store the global states. For example, applications may want to store the information of a log-in user for use in the whole application, this situation is suitable for using stores to store user information.

These global states can also include some business logic for processing global states.

## Conclusion

This way of separating states and logic into individual materials increases development resources. These resources can be reused and accelerate the speed of future development.

Another advantage of this way is to make the codebase more maintainable to accomplish decoupling and cohesion principles.
