---
title: '前端的累積式開發 (Accumulation Development)'
slug: 'accumulation-development-in-frontend'
author: 'Samuel Wang'
description: '在軟體開發中，有許多可以重複使用先前開發成果的機會，可以避免重複造輪子，並加速開發。'
tags: ['Frontend', 'Engineering']
releaseDate: '2025-04-12'
updateDate: '2025-04-12'
---

在軟體開發中，有許多可以重複使用先前開發成果的機會，可以避免重複造輪子，並加速開發。

本文將介紹在前端開發中哪些部分有機會可以被重複使用。

一般軟體開發流程大致會經過：

1. **需求定義階段：** PM 定義需求
2. **系統分析階段：** 系統分析師/設計師定義如何實作功能，並提供線框或 mockup
3. **開發階段：** 前端工程師實作 UI 與功能
4. **驗證階段：** 相關利害關係人/QA 測試功能
5. **部署階段：** 功能上線

## UI 設計系統

UI 設計系統是一組可重複使用的元件、規範與標準，能幫助團隊在數位產品中建立一致且具有整體性的使用者介面（UI）。

設計系統的關鍵要素包括：

1. **設計標記（Design tokens）** — 最小的樣式值，例如顏色、字型、間距等
2. **元件（Components）** — 可重用的 UI 元件（按鈕、卡片、對話框），具有一致的行為與樣式
3. **模式（Patterns）** — 常見的 UX 解法（表單佈局、錯誤處理）
4. **品牌指引（Brand guidelines）** — 聲調、標誌、影像與整體品牌規範
5. **文件（Documentation）** — 詳細的使用指南、注意事項與給開發者的程式範例

建立設計系統可重用元素以加速設計並提升一致性，增加系統可擴展性。新設計可以在原有基礎上延伸，快速加入功能與改善使用者體驗，並藉由標準化提升協作效率。

## 前端的職責

前端的核心職責可能包括：

- **UI 開發**
- **狀態管理**
- **API 整合**
- 效能優化
- 跨瀏覽器相容性
- 響應式設計
- 無障礙（Accessibility）
- 建置與工具鏈
- 測試

前端日常開發主要通常為 UI 開發、狀態管理與 API 整合。

## 將職責對應到實作

**UI 開發** 在現代前端中，UI 大多以元件化的方式實作，而非純 HTML 檔案。開發者需要思考哪些元件可以被重複使用，可以提升開發效率與維護性。

**API 整合** 建議以純函式實作，API 函式的責任為接受 API 定義的參數並向伺服器發出請求。

**狀態管理** 則涵蓋業務邏輯與 UI 行為的封裝，這些實作會放在 services、store，以及 reactivity/signal 等機制中。

## 把所有東西寫在單一元件的缺點

有時候前端研發會把所有實作寫在單一元件中。這種作法在短期內是可行的，功能也能達成，但會違反 DRY 原則，導致實作無法在未來重複使用。例如，開發者可能必須一再重複實作相同的 UI，同樣的邏輯也可能重複出現，後續的維護會變得非常困難。

為避免此情形並加速開發速度，應盡量將可重用的部分抽取出來。

## 在前端開發中定義類別（Categories）

常見的前端開發流程如下：

1. 整合 API 並取得回應資料
2. 將回應資料轉換為視圖模型並處理業務邏輯
3. 實作 UI
4. 管理視圖的狀態

在上述流程中，每個階段的程式碼都可以分類到不同類別，以利維護與重用。

常見類別：

- 資料存取（Data Access）
- 服務（Service）
- 元件（Component）
- Hook/Reactivity/Signal
- Store

以下分別說明各類別。

## 資料存取

應用程式通常會向伺服器或本地儲存取送資料。這些存取行為可以寫成純函式。將資料存取邏輯與元件分離可以降低元件的耦合，並在其他地方重複使用。

以純函式撰寫資料存取也比較容易測試：給定特定參數與模擬回應，並驗證輸出。

常見做法是把資料存取函式放在 `apis` 或 `data` 目錄中。

## 服務（Service）

表現層的資料介面通常與後端資料介面不同。取得資料後，需要把後端資料介面轉換為表現層的資料介面，例如把 HTTP 傳輸中的數字 enum 轉換成前端資料介面所使用的 enum。

Service 不需要管理狀態，因此可以以純函式實作並放在 `services` 目錄中。

## 元件（Component）

早已有人意識到，將一個元件拆成多個具有良好介面定義的子元件，可以提升可維護性。

當所有邏輯都集中在單一元件時，該元件可能需要管理許多狀態來控制不同的畫面顯示，導致元件膨脹且難以修改。

元件大致可分為純 UI 元件（pure UI component）與智慧元件（smart component）。

純 UI 元件不負責業務邏輯，只做呈現與特定行為；智慧元件則同時處理業務邏輯。

為了使元件可重用，元件介面需保持低耦合與高內聚。共用元件不應該知道任何特定頁面的特有邏輯——它們應僅透過 props 接收資料並實現自己的職責。

## Hook / Reactivity / Signal

過去前端主要是使用命令式程式設計 (imperative programming)，例如要更新元素文字時需先找到該元素再更新其 innerHTML。現在現代框架採用資料導向（declarative/data-driven）模式：只要在元素上加上對應指令並綁定資料與狀態，資料改變時畫面會自動更新。

這種模式稱為資料驅動（data-driven），而資料的管理即狀態管理。

在現代前端中，狀態管理非常重要，應用越複雜，狀態也越複雜。Vue 有其 reactivity 系統，Angular 提供 RxJS 與 signals，React 則使用 hooks 來重用狀態。狀態管理通常也包含一些與畫面渲染相關的邏輯。

過去 Reactivity 的狀態通常放在元件中，現在可以把它們抽成獨立函式，例如 React 的 hooks 或 Vue 的 composables，以便重用畫面狀態。

## Store

Reactivity 的狀態通常在本地元件使用，而全域狀態則放在 store。常見的 state 管理套件如 Redux、Pinia，這些 library 被稱為 store management，用來管理全域或區域的狀態，例如整個應用需使用的登入使用者資訊。

這些全域狀態也可以包含用於處理全域狀態的業務邏輯。

## 結論

把狀態與邏輯拆成獨立的模組與函式，可以累積開發資源。這些資源可被重複使用，從而加快未來開發速度。

另一個優點是提高程式碼庫的可維護性，達成低耦合與高內聚的設計原則。
